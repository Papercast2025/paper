<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=1440, initial-scale=1.0" />
  <title>Environmental Snapshot</title>
  <style>
    body {
      background-color: #f0f0f0;
      color: #000;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      width: 1440px;
      height: 2560px;
      -webkit-text-size-adjust: none;
    }
    .container {
      padding: 32px;
      display: flex;
      flex-direction: column;
      gap: 28px;
    }
    /* Card frame */
    .section {
      border: 4px solid #000;
      padding: 16px;
      border-radius: 8px;
      background-color: #fff;
      display: flex;
      flex-direction: column;
      position: relative;
    }
    /* Card header */
    .card-title {
      font-size: 36px;
      font-weight: bold;
      background-color: #000;
      color: #fff;
      padding: 4px 8px;
      margin-bottom: 8px;
      text-align: left;
    }
    /* River header */
    .river-header {
      background-color: black;
      color: white;
      font-size: 36px;
      font-weight: bold;
      padding: 10px 8px;
      text-align: center;
      margin-bottom: 8px;
    }
    /* Centered sections */
    .centered .section-content {
      align-items: center;
      text-align: center;
    }
    .section-content {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      text-align: right;
    }
    .value {
      font-size: 100px;
      font-weight: bold;
      margin: 10px 0;
    }
    .label {
      font-size: 32px;
      color: #444;
    }
    .timestamp, .card-timestamp {
      font-size: 24px;
      color: #222;
      margin-top: 8px;
      text-align: right;
    }
    /* Hide old river measurement element */
    #river-stage { display: none; }
    /* River graph container with gray background */
    #river-graph {
      background-color: #cccccc;
      display: block;
      margin: 12px auto 0 auto;
      position: relative;
    }
    /* USGS site info */
    #usgs-site-info {
      width: 100%;
      text-align: right;
      font-size: 20px;
      color: #666;
      margin-top: 8px;
    }
    /* Flood status styling */
    #flood-status {
      font-weight: bold;
      font-size: 48px;
      margin-top: 8px;
      display: inline-block;
      text-align: center;
    }
    /* Y-axis label styling */
    #y-axis-label {
      font-size: 21px;
      font-weight: bold;
      fill: black;
      transform: rotate(-90deg);
      transform-origin: 20px 140px;
    }
    /* Header styling */
    #header {
      background-color: black;
      color: white;
      padding: 20px;
      text-align: center;
      font-size: 43px;
      font-weight: bold;
    }
    #header a { color: white; text-decoration: underline; }
    /* Weather Conditions: two-column layout */
    #weather-section .section-content {
      flex-direction: row;
      justify-content: space-between;
      width: 100%;
    }
    #weather-temp-container {
      display: flex;
      align-items: center;
      text-align: left;
    }
    #weather-temp-F { font-size: 100px; font-weight: bold; }
    #weather-temp-C { font-size: 50px; font-weight: bold; }
    #weather-details { text-align: right; }
    #weather-details div { font-size: 40px; font-weight: bold; }
    /* Alerts text bold */
    #alert-message { font-weight: bold; }
  </style>
</head>
<body>
  <!-- Header -->
  <div id="header">
    Catham County Parks and Recreation (<span id="header-lat">35.77659</span> / <span id="header-lon">-79.14597</span>)
    <a href="https://www.chathamcountync.gov/parks-recreation" target="_blank">www.chathamcountync.gov/parks-recreation</a>
  </div>
  <div class="container">
    <!-- Heat Risk Section -->
    <div class="section centered" id="heat-risk-section">
      <div class="card-title">Heat Risk</div>
      <div class="section-content" id="heat-risk-content">
        <div class="value" id="heat-risk-level">--</div>
      </div>
      <div id="heat-risk-graphic"></div>
      <div class="card-timestamp" id="heat-risk-timestamp">Last updated: --</div>
    </div>

    <!-- Alerts Section -->
    <div class="section centered" id="alerts-section">
      <div class="card-title">Alerts</div>
      <div class="section-content">
        <div class="label" id="alert-message">No alerts at this time.</div>
      </div>
      <div class="card-timestamp" id="alerts-timestamp">Last updated: --</div>
    </div>

    <!-- Weather Conditions Section -->
    <div class="section centered" id="weather-section">
      <div class="card-title">Weather Conditions</div>
      <div class="section-content">
        <div id="weather-temp-container">
          <!-- Weather icon to the left -->
          <div id="weather-icon" style="margin-right: 10px;"></div>
          <div>
            <div id="weather-temp-F">--°F</div>
            <div id="weather-temp-C">--°C</div>
          </div>
        </div>
        <div id="weather-details">
          <div id="weather-forecast">--</div>
          <div id="weather-wind">Wind: -- mph</div>
          <div id="weather-humidity">Humidity: --%</div>
        </div>
      </div>
      <div class="card-timestamp" id="weather-timestamp">Last updated: --</div>
    </div>

    <!-- River & Water Levels Section -->
    <div class="section" id="river-section">
      <div class="river-header">River & Water Levels</div>
      <div class="section-content" style="margin-top: 56px; padding: 0 16px; text-align: center;">
        <div class="label" id="flood-status"></div>
      </div>
      <div id="river-graph"></div>
      <div id="usgs-site-info">USGS Site #02096960 (Live)</div>
      <div class="card-timestamp" id="river-timestamp">Last updated: --</div>
    </div>

    <!-- AQI Section (above Rainfall Forecast) -->
    <div class="section centered" id="aqi-section">
      <div class="card-title">Air Quality Index</div>
      <!-- AQI gauge container will hold the half‑circle gauge -->
      <div class="section-content" id="aqi-content">
        <div id="aqi-gauge-container"></div>
        <!-- AQI info (category & measurement) below the gauge -->
        <div id="aqi-info" style="font-size:36px; font-weight:bold; text-align:center; margin-top:10px;"></div>
      </div>
      <div class="card-timestamp" id="aqi-timestamp">Last updated: --</div>
    </div>

    <!-- Rainfall Forecast Section -->
    <div class="section centered" id="rainfall-forecast">
      <div class="card-title">Rainfall Forecast</div>
      <div class="section-content">
        <div class="label" id="rainfall-forecast-1">--</div>
        <div class="label" id="rainfall-forecast-2">--</div>
        <div class="label" id="rainfall-forecast-3">--</div>
      </div>
      <div class="card-timestamp" id="rainfall-timestamp">Last updated: --</div>
    </div>
  </div>

  <script>
    // Global location
    let LAT = 35.77659;
    let LON = -79.14597;
    document.getElementById('header-lat').textContent = LAT;
    document.getElementById('header-lon').textContent = LON;
    const AIRNOW_API_KEY = '26158E56-5836-46D3-B819-92969016332B';
    let floodThreshold = 5.0;

    // ----------------------------------------------------------
    // 1) Generate a half‑circle AQI gauge with colored segments
    // ----------------------------------------------------------
    function generateAirNowArcGauge(aqi, category) {
      const svgNS = "http://www.w3.org/2000/svg";
      const width = 300;
      const height = 150;
      const centerX = width / 2;
      const centerY = height;
      const radius = 100;
      const strokeWidth = 20;
      const segments = [
        { from: 0,   to: 50,  color: "#00e400" },
        { from: 50,  to: 100, color: "#ffff00" },
        { from: 100, to: 150, color: "#ff7e00" },
        { from: 150, to: 200, color: "#ff0000" },
        { from: 200, to: 300, color: "#8f3f97" }
      ];
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("width", width);
      svg.setAttribute("height", height);
      svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
      segments.forEach(seg => {
        const startAngle = (seg.from / 300) * 180;
        const endAngle = (seg.to / 300) * 180;
        const startRad = (Math.PI * (180 - startAngle)) / 180;
        const endRad   = (Math.PI * (180 - endAngle)) / 180;
        const startX = centerX + radius * Math.cos(startRad);
        const startY = centerY - radius * Math.sin(startRad);
        const endX = centerX + radius * Math.cos(endRad);
        const endY = centerY - radius * Math.sin(endRad);
        const largeArcFlag = 0;
        const pathData = `M ${startX} ${startY} A ${radius} ${radius} 0 ${largeArcFlag} 0 ${endX} ${endY}`;
        const path = document.createElementNS(svgNS, "path");
        path.setAttribute("d", pathData);
        path.setAttribute("stroke", seg.color);
        path.setAttribute("stroke-width", strokeWidth);
        path.setAttribute("fill", "none");
        svg.appendChild(path);
      });
      // Draw pointer based on AQI value
      const clampedAQI = Math.min(Math.max(aqi, 0), 300);
      const pointerAngle = (clampedAQI / 300) * 180;
      const pointerRad = (Math.PI * (180 - pointerAngle)) / 180;
      const pointerLen = radius - strokeWidth / 2;
      const pointerX = centerX + pointerLen * Math.cos(pointerRad);
      const pointerY = centerY - pointerLen * Math.sin(pointerRad);
      const pointerLine = document.createElementNS(svgNS, "line");
      pointerLine.setAttribute("x1", centerX);
      pointerLine.setAttribute("y1", centerY);
      pointerLine.setAttribute("x2", pointerX);
      pointerLine.setAttribute("y2", pointerY);
      pointerLine.setAttribute("stroke", "black");
      pointerLine.setAttribute("stroke-width", "4");
      pointerLine.setAttribute("stroke-linecap", "round");
      svg.appendChild(pointerLine);
      return svg;
    }

    // ----------------------------------------------------------
    // 2) Heat Risk: reduced gauge scale and graphic
    // ----------------------------------------------------------
    function getHeatRiskGraphic(riskLevel) {
      const svgNS = "http://www.w3.org/2000/svg";
      const size = 50;
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("width", size);
      svg.setAttribute("height", size);
      svg.setAttribute("viewBox", "0 0 64 64");
      let shape = "";
      if (riskLevel === "Minimal Heat Risk") {
        shape = `<circle cx="32" cy="32" r="20" fill="#00aaff" stroke="black" stroke-width="3"/>`;
      } else if (riskLevel === "Moderate Heat Risk") {
        shape = `<circle cx="32" cy="32" r="20" fill="#ffff00" stroke="black" stroke-width="3"/>`;
      } else if (riskLevel === "High Heat Risk") {
        shape = `<circle cx="32" cy="32" r="20" fill="#ff7e00" stroke="black" stroke-width="3"/>`;
      } else if (riskLevel === "Extreme Heat Risk") {
        shape = `<circle cx="32" cy="32" r="20" fill="#ff0000" stroke="black" stroke-width="3"/>`;
      } else {
        shape = `<circle cx="32" cy="32" r="20" fill="#cccccc" stroke="black" stroke-width="3"/>`;
      }
      svg.innerHTML = shape;
      return svg;
    }
    
    function updateHeatRisk(tempF, RH) {
      let HI = tempF;
      if (tempF >= 80) {
        const c1 = -42.379, c2 = 2.04901523, c3 = 10.14333127;
        const c4 = -0.22475541, c5 = -6.83783e-3, c6 = -5.481717e-2;
        const c7 = 1.22874e-3, c8 = 8.5282e-4, c9 = -1.99e-6;
        HI = c1 + c2 * tempF + c3 * RH + c4 * tempF * RH + c5 * (tempF * tempF) + c6 * (RH * RH) +
             c7 * (tempF * tempF) * RH + c8 * tempF * (RH * RH) + c9 * (tempF * tempF) * (RH * RH);
      }
      const riskLevel = (tempF < 80) ? "Minimal Heat Risk" :
                        (HI < 90) ? "Moderate Heat Risk" :
                        (HI < 105) ? "High Heat Risk" : "Extreme Heat Risk";
      const heatTime = new Date().toLocaleString(undefined, { dateStyle: 'short', timeStyle: 'short' });
      document.getElementById('heat-risk-timestamp').textContent = "Last updated: " + heatTime;
      // Use a reduced scale (3.0) for the gauge
      if (riskLevel === "Minimal Heat Risk") {
        document.getElementById('heat-risk-level').textContent = riskLevel;
      } else {
        let color = (riskLevel === "Moderate Heat Risk") ? "#FFFF00"
                  : (riskLevel === "High Heat Risk") ? "#FFA500"
                  : (riskLevel === "Extreme Heat Risk") ? "#FF0000"
                  : "#000000";
        document.getElementById('heat-risk-level').innerHTML = generateGauge(HI, 80, 120, riskLevel, color, false, 3.0);
      }
      // Append heat risk graphic below gauge
      const graphicContainer = document.getElementById('heat-risk-graphic');
      graphicContainer.innerHTML = "";
      graphicContainer.appendChild(getHeatRiskGraphic(riskLevel));
    }
    
    // ----------------------------------------------------------
    // 3) fetchAQIData: use half‑circle gauge for AQI
    // ----------------------------------------------------------
    function fetchAQIData() {
      const url = `https://www.airnowapi.org/aq/observation/latLong/current/?format=application/json&latitude=${LAT}&longitude=${LON}&distance=50&API_KEY=${AIRNOW_API_KEY}`;
      fetch(url)
        .then(res => res.json())
        .then(data => {
          const aqiTime = new Date().toLocaleString(undefined, { dateStyle: 'short', timeStyle: 'short' });
          document.getElementById('aqi-timestamp').textContent = "Last updated: " + aqiTime;
          const container = document.getElementById("aqi-gauge-container");
          container.innerHTML = "";
          const infoDiv = document.getElementById("aqi-info");
          infoDiv.innerHTML = "";
          if (data && data.length > 0) {
            const main = data[0];
            const aqiValue = parseInt(main.AQI, 10) || 0;
            const category = main.Category.Name || "Unknown";
            const gauge = generateAirNowArcGauge(aqiValue, category);
            container.appendChild(gauge);
            // Below gauge, show category and measurement text.
            infoDiv.textContent = category.toUpperCase() + " - AQI: " + aqiValue;
          } else {
            const gauge = generateAirNowArcGauge(42, "Good");
            container.appendChild(gauge);
            infoDiv.textContent = "GOOD - AQI: 42";
          }
        })
        .catch(err => {
          console.error('Error fetching AQI data:', err);
          document.getElementById('aqi-timestamp').textContent = "Last updated: N/A";
          const container = document.getElementById("aqi-gauge-container");
          container.innerHTML = "";
          const infoDiv = document.getElementById("aqi-info");
          container.appendChild(generateAirNowArcGauge(42, "Good"));
          infoDiv.textContent = "GOOD - AQI: 42";
        });
    }
    
    // ----------------------------------------------------------
    // 4) fetchNWSData: Weather Conditions
    // ----------------------------------------------------------
    function getWeatherIcon(forecast) {
      forecast = forecast.toLowerCase();
      let iconSVG = "";
      if (forecast.includes("sunny") || forecast.includes("clear")) {
        iconSVG = `<svg width="60" height="60" viewBox="0 0 64 64">
          <circle cx="32" cy="32" r="12" fill="black" stroke="black" stroke-width="3"/>
          <g stroke="black" stroke-width="3">
            <line x1="32" y1="4" x2="32" y2="14"/>
            <line x1="32" y1="50" x2="32" y2="60"/>
            <line x1="4" y1="32" x2="14" y2="32"/>
            <line x1="50" y1="32" x2="60" y2="32"/>
            <line x1="12" y1="12" x2="18" y2="18"/>
            <line x1="46" y1="46" x2="52" y2="52"/>
            <line x1="12" y1="52" x2="18" y2="46"/>
            <line x1="46" y1="18" x2="52" y2="12"/>
          </g>
        </svg>`;
      } else if (forecast.includes("cloud")) {
        iconSVG = `<svg width="60" height="60" viewBox="0 0 64 64">
          <path d="M20,40a12,12 0 0,1 24,0h8a8,8 0 0,0 0-16 10,10 0 0,0-19-4 12,12 0 0,0-19,4 8,8 0 0,0 0,16z" fill="black" stroke="black" stroke-width="3"/>
        </svg>`;
      } else if (forecast.includes("rain")) {
        iconSVG = `<svg width="60" height="60" viewBox="0 0 64 64">
          <path d="M20,40a12,12 0 0,1 24,0h8a8,8 0 0,0 0-16 10,10 0 0,0-19-4 12,12 0 0,0-19,4 8,8 0 0,0 0,16z" fill="black" stroke="black" stroke-width="3"/>
          <g stroke="black" stroke-width="3">
            <line x1="22" y1="48" x2="22" y2="58"/>
            <line x1="32" y1="48" x2="32" y2="58"/>
            <line x1="42" y1="48" x2="42" y2="58"/>
          </g>
        </svg>`;
      } else if (forecast.includes("snow")) {
        iconSVG = `<svg width="60" height="60" viewBox="0 0 64 64">
          <path d="M20,40a12,12 0 0,1 24,0h8a8,8 0 0,0 0-16 10,10 0 0,0-19-4 12,12 0 0,0-19,4 8,8 0 0,0 0,16z" fill="black" stroke="black" stroke-width="3"/>
          <g stroke="black" stroke-width="3">
            <line x1="32" y1="48" x2="32" y2="60"/>
            <line x1="26" y1="52" x2="38" y2="52"/>
          </g>
        </svg>`;
      } else {
        iconSVG = `<svg width="60" height="60" viewBox="0 0 64 64">
          <circle cx="22" cy="22" r="10" fill="black" stroke="black" stroke-width="3"/>
          <path d="M20,40a12,12 0 0,1 24,0h8a8,8 0 0,0 0-16 10,10 0 0,0-19-4 12,12 0 0,0-19,4 8,8 0 0,0 0,16z" fill="black" stroke="black" stroke-width="3"/>
        </svg>`;
      }
      return iconSVG;
    }

    function fetchNWSData() {
      const nwsTime = new Date().toLocaleString(undefined, { dateStyle: 'short', timeStyle: 'short' });
      document.getElementById('weather-timestamp').textContent = "Last updated: " + nwsTime;
      document.getElementById('alerts-timestamp').textContent = "Last updated: " + nwsTime;
      document.getElementById('rainfall-timestamp').textContent = "Last updated: " + nwsTime;
      const pointUrl = `https://api.weather.gov/points/${LAT},${LON}`;
      fetch(pointUrl)
        .then(res => res.json())
        .then(pointData => {
          const obsUrl = pointData.properties.forecastHourly;
          const gridUrl = pointData.properties.forecast;
          const alertZone = pointData.properties.forecastZone;
          fetch(obsUrl)
            .then(res => res.json())
            .then(obsData => {
              if (obsData.properties && obsData.properties.periods && obsData.properties.periods.length > 0) {
                const now = obsData.properties.periods[0];
                const tempF = now.temperature;
                const tempC = ((tempF - 32) * 5/9).toFixed(1);
                document.getElementById('weather-temp-F').textContent = `${tempF ?? '--'}°F`;
                document.getElementById('weather-temp-C').textContent = `${tempC}°C`;
                document.getElementById('weather-forecast').textContent = now.shortForecast || 'N/A';
                document.getElementById('weather-wind').textContent = `Wind: ${now.windSpeed || '--'} mph`;
                document.getElementById('weather-humidity').textContent = `Humidity: ${now.relativeHumidity && now.relativeHumidity.value ? now.relativeHumidity.value : '--'}%`;
                document.getElementById('weather-icon').innerHTML = getWeatherIcon(now.shortForecast);
                updateHeatRisk(tempF, now.relativeHumidity ? now.relativeHumidity.value : 0);
              }
            })
            .catch(err => console.error('Error fetching weather observations:', err));
          fetch(gridUrl)
            .then(res => res.json())
            .then(gridData => {
              if (gridData.properties && gridData.properties.periods) {
                const days = gridData.properties.periods.slice(0, 3);
                document.getElementById('rainfall-forecast-1').textContent =
                  `${days[0]?.name || 'Day1'}: ${days[0]?.shortForecast || 'N/A'}`;
                document.getElementById('rainfall-forecast-2').textContent =
                  `${days[1]?.name || 'Day2'}: ${days[1]?.shortForecast || 'N/A'}`;
                document.getElementById('rainfall-forecast-3').textContent =
                  `${days[2]?.name || 'Day3'}: ${days[2]?.shortForecast || 'N/A'}`;
              }
            })
            .catch(err => console.error('Error fetching rainfall forecast:', err));
          if (alertZone) {
            const zoneId = alertZone.split('/').pop();
            const alertUrl = `https://api.weather.gov/alerts/active/zone/${zoneId}`;
            fetch(alertUrl)
              .then(res => res.json())
              .then(alertData => {
                if (alertData.features && alertData.features.length > 0) {
                  const alertMsg = alertData.features.map(a => a.properties.headline).join(' | ');
                  document.getElementById('alert-message').textContent = alertMsg;
                } else {
                  document.getElementById('alert-message').textContent = 'No alerts at this time.';
                }
              })
              .catch(err => console.error('Error fetching alerts:', err));
          }
        })
        .catch(err => console.error('Error fetching NWS points data:', err));
    }

    // ----------------------------------------------------------
    // 4) fetchRiverData & renderRiverGraph: update y-axis and line weight
    // ----------------------------------------------------------
    function fetchRiverData() {
      const end = new Date();
      const start = new Date();
      start.setDate(end.getDate() - 4);
      const format = d => d.toISOString().split('.')[0];
      const url = `https://waterservices.usgs.gov/nwis/iv/?format=json&sites=02096960&parameterCd=00065&startDT=${format(start)}&endDT=${format(end)}&siteStatus=all`;
      fetch(url)
        .then(res => res.json())
        .then(data => {
          const siteProps = data.value.timeSeries[0].sourceInfo.siteProperty;
          if (siteProps) {
            siteProps.forEach(prop => {
              if (prop.propertyName === "floodStage") {
                floodThreshold = parseFloat(prop.value);
              }
            });
          }
          const rawValues = data.value.timeSeries[0].values[0].value || [];
          const floatValues = rawValues
            .map(v => ({ dateTime: v.dateTime, stage: parseFloat(v.value) }))
            .filter(pt => !isNaN(pt.stage));
          if (floatValues.length === 0) {
            document.getElementById('river-stage').textContent = 'No data available';
            return;
          }
          const lastReading = floatValues[floatValues.length - 1].stage;
          const lastReadingStr = `${lastReading.toFixed(2)} ft`;
          document.getElementById("river-timestamp").textContent = new Date().toLocaleString(undefined, { dateStyle: 'short', timeStyle: 'short' });
          const statusEl = document.getElementById("flood-status");
          if (lastReading >= floodThreshold) {
            statusEl.textContent = "AT OR ABOVE FLOOD STAGE";
            statusEl.style.fontSize = "48px";
            statusEl.style.backgroundColor = "black";
            statusEl.style.color = "white";
            statusEl.style.textTransform = "uppercase";
            statusEl.style.padding = "5px";
            statusEl.style.margin = "0 auto";
          } else {
            statusEl.innerHTML = "&#9888; BELOW FLOOD STAGE";
            statusEl.style.fontSize = "48px";
            statusEl.style.backgroundColor = "white";
            statusEl.style.color = "black";
            statusEl.style.textTransform = "uppercase";
            statusEl.style.padding = "5px";
            statusEl.style.margin = "0 auto";
          }
          const groupedValues = groupBy3HourBlocks(floatValues);
          renderRiverGraph(groupedValues, floodThreshold, lastReadingStr);
        })
        .catch(err => {
          console.error('USGS River Data fetch error:', err);
          document.getElementById('river-stage').textContent = 'Error fetching data';
        });
    }

    function groupBy3HourBlocks(dataArray) {
      const blockMap = {};
      dataArray.forEach(pt => {
        const date = new Date(pt.dateTime);
        const y = date.getFullYear();
        const m = date.getMonth();
        const d = date.getDate();
        const hBlock = Math.floor(date.getHours() / 3) * 3;
        const blockDate = new Date(y, m, d, hBlock, 0, 0, 0);
        const key = blockDate.toISOString();
        if (!blockMap[key]) {
          blockMap[key] = { dateObj: blockDate, sum: 0, count: 0 };
        }
        blockMap[key].sum += pt.stage;
        blockMap[key].count += 1;
      });
      return Object.values(blockMap)
        .map(item => ({ dateObj: item.dateObj, stage: item.sum / item.count }))
        .sort((a, b) => a.dateObj - b.dateObj);
    }

    function renderRiverGraph(dataPoints, floodThreshold, lastReadingStr) {
      const container = document.getElementById("river-graph");
      container.innerHTML = "";
      if (!dataPoints.length) return;
      let minStage = Math.min(...dataPoints.map(d => d.stage));
      let maxStage = Math.max(...dataPoints.map(d => d.stage));
      // Ensure y-axis goes up to at least 6 ft.
      maxStage = Math.max(maxStage, 6);
      minStage = Math.min(minStage, floodThreshold);
      maxStage = Math.max(maxStage, floodThreshold);
      const stageRange = (maxStage - minStage) || 1;
      const minDate = dataPoints[0].dateObj;
      const maxDate = dataPoints[dataPoints.length - 1].dateObj;
      const totalMillis = maxDate - minDate;
      const svgWidth = 1152;
      const svgHeight = 280;
      const graphHeight = 180;
      const graphOffsetX = 60;
      const graphWidth = svgWidth - graphOffsetX - 20;
      const svgNS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("width", svgWidth);
      svg.setAttribute("height", svgHeight);
      svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
      // Add y-axis label
      const yLabel = document.createElementNS(svgNS, "text");
      yLabel.setAttribute("x", 20);
      yLabel.setAttribute("y", 140);
      yLabel.setAttribute("font-size", "21");
      yLabel.setAttribute("font-weight", "bold");
      yLabel.setAttribute("fill", "black");
      yLabel.textContent = "Water Level (ft)";
      yLabel.setAttribute("transform", "rotate(-90 20,140)");
      svg.appendChild(yLabel);
      function scaleX(dateObj) {
        const currentMillis = dateObj - minDate;
        return graphOffsetX + (currentMillis / totalMillis) * graphWidth;
      }
      function scaleY(stage) {
        return graphHeight - ((stage - minStage) / stageRange) * graphHeight + 20;
      }
      // Y-axis ticks (font-size 21px; remove "ft" from tick labels)
      const startTick = Math.floor(minStage * 2) / 2;
      const endTick = Math.ceil(maxStage * 2) / 2;
      for (let tickVal = startTick; tickVal <= endTick; tickVal += 0.5) {
        const fraction = (maxStage - tickVal) / stageRange;
        const tickY = 20 + fraction * graphHeight;
        const tickLine = document.createElementNS(svgNS, "line");
        tickLine.setAttribute("x1", graphOffsetX - 5);
        tickLine.setAttribute("x2", graphOffsetX);
        tickLine.setAttribute("y1", tickY);
        tickLine.setAttribute("y2", tickY);
        tickLine.setAttribute("stroke", "black");
        tickLine.setAttribute("stroke-width", "1");
        svg.appendChild(tickLine);
        const tickLabel = document.createElementNS(svgNS, "text");
        tickLabel.setAttribute("x", graphOffsetX - 10);
        tickLabel.setAttribute("y", tickY + 4);
        tickLabel.setAttribute("font-size", "21");
        tickLabel.setAttribute("fill", "black");
        tickLabel.setAttribute("text-anchor", "end");
        tickLabel.textContent = tickVal.toFixed(1);
        svg.appendChild(tickLabel);
      }
      // Data path with increased stroke-width by 10% (from 6 to 6.6)
      const pathData = dataPoints.map((pt, i) => {
        const x = scaleX(pt.dateObj);
        const y = scaleY(pt.stage);
        return (i === 0 ? 'M' : 'L') + x + ',' + y;
      }).join(' ');
      const polyline = document.createElementNS(svgNS, "path");
      polyline.setAttribute("d", pathData);
      polyline.setAttribute("stroke", "black");
      polyline.setAttribute("fill", "none");
      polyline.setAttribute("stroke-width", "6.6");
      svg.appendChild(polyline);
      // Flood line
      const floodY = graphHeight - ((floodThreshold - minStage) / stageRange) * graphHeight + 20;
      const floodLine = document.createElementNS(svgNS, "line");
      floodLine.setAttribute("x1", graphOffsetX);
      floodLine.setAttribute("x2", graphOffsetX + graphWidth);
      floodLine.setAttribute("y1", floodY);
      floodLine.setAttribute("y2", floodY);
      floodLine.setAttribute("stroke", "black");
      floodLine.setAttribute("stroke-dasharray", "6,3");
      floodLine.setAttribute("stroke-width", "4");
      svg.appendChild(floodLine);
      // Date labels along x-axis (without a "Date" label)
      const minDateLabel = minDate.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
      let lastDay = "";
      dataPoints.forEach((pt, i) => {
        const x = scaleX(pt.dateObj);
        const y = scaleY(pt.stage);
        const circle = document.createElementNS(svgNS, "circle");
        circle.setAttribute("cx", x);
        circle.setAttribute("cy", y);
        circle.setAttribute("r", 3);
        circle.setAttribute("fill", "black");
        svg.appendChild(circle);
        const dayLabel = pt.dateObj.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
        if (dayLabel !== minDateLabel && dayLabel !== lastDay) {
          lastDay = dayLabel;
          const label = document.createElementNS(svgNS, "text");
          label.setAttribute("x", x);
          label.setAttribute("y", 240);
          label.setAttribute("font-size", "30");
          label.setAttribute("fill", "black");
          label.setAttribute("text-anchor", "middle");
          label.textContent = dayLabel;
          svg.appendChild(label);
        }
        // For the last data point, add the water measurement text
        if (i === dataPoints.length - 1) {
          const measurement = document.createElementNS(svgNS, "text");
          measurement.setAttribute("x", x);
          measurement.setAttribute("y", y + 45);
          measurement.setAttribute("font-size", "35");
          measurement.setAttribute("font-weight", "bold");
          measurement.setAttribute("fill", "white");
          measurement.setAttribute("text-anchor", "middle");
          measurement.textContent = ` ${lastReadingStr} `;
          const rect = document.createElementNS(svgNS, "rect");
          setTimeout(() => {
            const bbox = measurement.getBBox();
            rect.setAttribute("x", bbox.x - 5);
            rect.setAttribute("y", bbox.y);
            rect.setAttribute("width", bbox.width + 10);
            rect.setAttribute("height", bbox.height);
            rect.setAttribute("fill", "black");
          }, 0);
          setTimeout(() => {
            const bbox = measurement.getBBox();
            rect.setAttribute("x", bbox.x - 5);
            rect.setAttribute("y", bbox.y);
            rect.setAttribute("width", bbox.width + 10);
            rect.setAttribute("height", bbox.height);
            svg.insertBefore(rect, measurement);
          }, 0);
          svg.appendChild(measurement);
        }
      });
      container.appendChild(svg);
    }

    // ----------------------------------------------------------
    // 4) fetchNWSData: Weather Conditions
    // ----------------------------------------------------------
    function fetchNWSData() {
      const nwsTime = new Date().toLocaleString(undefined, { dateStyle: 'short', timeStyle: 'short' });
      document.getElementById('weather-timestamp').textContent = "Last updated: " + nwsTime;
      document.getElementById('alerts-timestamp').textContent = "Last updated: " + nwsTime;
      document.getElementById('rainfall-timestamp').textContent = "Last updated: " + nwsTime;
      const pointUrl = `https://api.weather.gov/points/${LAT},${LON}`;
      fetch(pointUrl)
        .then(res => res.json())
        .then(pointData => {
          const obsUrl = pointData.properties.forecastHourly;
          const gridUrl = pointData.properties.forecast;
          const alertZone = pointData.properties.forecastZone;
          fetch(obsUrl)
            .then(res => res.json())
            .then(obsData => {
              if (obsData.properties && obsData.properties.periods && obsData.properties.periods.length > 0) {
                const now = obsData.properties.periods[0];
                const tempF = now.temperature;
                const tempC = ((tempF - 32) * 5/9).toFixed(1);
                document.getElementById('weather-temp-F').textContent = `${tempF ?? '--'}°F`;
                document.getElementById('weather-temp-C').textContent = `${tempC}°C`;
                document.getElementById('weather-forecast').textContent = now.shortForecast || 'N/A';
                document.getElementById('weather-wind').textContent = `Wind: ${now.windSpeed || '--'} mph`;
                document.getElementById('weather-humidity').textContent = `Humidity: ${now.relativeHumidity && now.relativeHumidity.value ? now.relativeHumidity.value : '--'}%`;
                document.getElementById('weather-icon').innerHTML = getWeatherIcon(now.shortForecast);
                updateHeatRisk(tempF, now.relativeHumidity ? now.relativeHumidity.value : 0);
              }
            })
            .catch(err => console.error('Error fetching weather observations:', err));
          fetch(gridUrl)
            .then(res => res.json())
            .then(gridData => {
              if (gridData.properties && gridData.properties.periods) {
                const days = gridData.properties.periods.slice(0, 3);
                document.getElementById('rainfall-forecast-1').textContent =
                  `${days[0]?.name || 'Day1'}: ${days[0]?.shortForecast || 'N/A'}`;
                document.getElementById('rainfall-forecast-2').textContent =
                  `${days[1]?.name || 'Day2'}: ${days[1]?.shortForecast || 'N/A'}`;
                document.getElementById('rainfall-forecast-3').textContent =
                  `${days[2]?.name || 'Day3'}: ${days[2]?.shortForecast || 'N/A'}`;
              }
            })
            .catch(err => console.error('Error fetching rainfall forecast:', err));
          if (alertZone) {
            const zoneId = alertZone.split('/').pop();
            const alertUrl = `https://api.weather.gov/alerts/active/zone/${zoneId}`;
            fetch(alertUrl)
              .then(res => res.json())
              .then(alertData => {
                if (alertData.features && alertData.features.length > 0) {
                  const alertMsg = alertData.features.map(a => a.properties.headline).join(' | ');
                  document.getElementById('alert-message').textContent = alertMsg;
                } else {
                  document.getElementById('alert-message').textContent = 'No alerts at this time.';
                }
              })
              .catch(err => console.error('Error fetching alerts:', err));
          }
        })
        .catch(err => console.error('Error fetching NWS points data:', err));
    }

    // ----------------------------------------------------------
    // 5) fetchRiverData & renderRiverGraph: River graph updates
    // ----------------------------------------------------------
    function fetchRiverData() {
      const end = new Date();
      const start = new Date();
      start.setDate(end.getDate() - 4);
      const format = d => d.toISOString().split('.')[0];
      const url = `https://waterservices.usgs.gov/nwis/iv/?format=json&sites=02096960&parameterCd=00065&startDT=${format(start)}&endDT=${format(end)}&siteStatus=all`;
      fetch(url)
        .then(res => res.json())
        .then(data => {
          const siteProps = data.value.timeSeries[0].sourceInfo.siteProperty;
          if (siteProps) {
            siteProps.forEach(prop => {
              if (prop.propertyName === "floodStage") {
                floodThreshold = parseFloat(prop.value);
              }
            });
          }
          const rawValues = data.value.timeSeries[0].values[0].value || [];
          const floatValues = rawValues
            .map(v => ({ dateTime: v.dateTime, stage: parseFloat(v.value) }))
            .filter(pt => !isNaN(pt.stage));
          if (floatValues.length === 0) {
            document.getElementById('river-stage').textContent = 'No data available';
            return;
          }
          const lastReading = floatValues[floatValues.length - 1].stage;
          const lastReadingStr = `${lastReading.toFixed(2)} ft`;
          document.getElementById("river-timestamp").textContent = new Date().toLocaleString(undefined, { dateStyle: 'short', timeStyle: 'short' });
          const statusEl = document.getElementById("flood-status");
          if (lastReading >= floodThreshold) {
            statusEl.textContent = "AT OR ABOVE FLOOD STAGE";
            statusEl.style.fontSize = "48px";
            statusEl.style.backgroundColor = "black";
            statusEl.style.color = "white";
            statusEl.style.textTransform = "uppercase";
            statusEl.style.padding = "5px";
            statusEl.style.margin = "0 auto";
          } else {
            statusEl.innerHTML = "&#9888; BELOW FLOOD STAGE";
            statusEl.style.fontSize = "48px";
            statusEl.style.backgroundColor = "white";
            statusEl.style.color = "black";
            statusEl.style.textTransform = "uppercase";
            statusEl.style.padding = "5px";
            statusEl.style.margin = "0 auto";
          }
          const groupedValues = groupBy3HourBlocks(floatValues);
          renderRiverGraph(groupedValues, floodThreshold, lastReadingStr);
        })
        .catch(err => {
          console.error('USGS River Data fetch error:', err);
          document.getElementById('river-stage').textContent = 'Error fetching data';
        });
    }

    function groupBy3HourBlocks(dataArray) {
      const blockMap = {};
      dataArray.forEach(pt => {
        const date = new Date(pt.dateTime);
        const y = date.getFullYear();
        const m = date.getMonth();
        const d = date.getDate();
        const hBlock = Math.floor(date.getHours() / 3) * 3;
        const blockDate = new Date(y, m, d, hBlock, 0, 0, 0);
        const key = blockDate.toISOString();
        if (!blockMap[key]) {
          blockMap[key] = { dateObj: blockDate, sum: 0, count: 0 };
        }
        blockMap[key].sum += pt.stage;
        blockMap[key].count += 1;
      });
      return Object.values(blockMap)
        .map(item => ({ dateObj: item.dateObj, stage: item.sum / item.count }))
        .sort((a, b) => a.dateObj - b.dateObj);
    }

    function renderRiverGraph(dataPoints, floodThreshold, lastReadingStr) {
      const container = document.getElementById("river-graph");
      container.innerHTML = "";
      if (!dataPoints.length) return;
      let minStage = Math.min(...dataPoints.map(d => d.stage));
      let maxStage = Math.max(...dataPoints.map(d => d.stage));
      // Ensure y-axis goes up to at least 6 ft.
      maxStage = Math.max(maxStage, 6);
      minStage = Math.min(minStage, floodThreshold);
      maxStage = Math.max(maxStage, floodThreshold);
      const stageRange = (maxStage - minStage) || 1;
      const minDate = dataPoints[0].dateObj;
      const maxDate = dataPoints[dataPoints.length - 1].dateObj;
      const totalMillis = maxDate - minDate;
      const svgWidth = 1152;
      const svgHeight = 280;
      const graphHeight = 180;
      const graphOffsetX = 60;
      const graphWidth = svgWidth - graphOffsetX - 20;
      const svgNS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("width", svgWidth);
      svg.setAttribute("height", svgHeight);
      svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
      // Add y-axis label "Water Level (ft)"
      const yLabel = document.createElementNS(svgNS, "text");
      yLabel.setAttribute("x", 20);
      yLabel.setAttribute("y", 140);
      yLabel.setAttribute("font-size", "21");
      yLabel.setAttribute("font-weight", "bold");
      yLabel.setAttribute("fill", "black");
      yLabel.textContent = "Water Level (ft)";
      yLabel.setAttribute("transform", "rotate(-90 20,140)");
      svg.appendChild(yLabel);
      function scaleX(dateObj) {
        const currentMillis = dateObj - minDate;
        return graphOffsetX + (currentMillis / totalMillis) * graphWidth;
      }
      function scaleY(stage) {
        return graphHeight - ((stage - minStage) / stageRange) * graphHeight + 20;
      }
      // Y-axis ticks (font-size 21px, no "ft")
      const startTick = Math.floor(minStage * 2) / 2;
      const endTick = Math.ceil(maxStage * 2) / 2;
      for (let tickVal = startTick; tickVal <= endTick; tickVal += 0.5) {
        const fraction = (maxStage - tickVal) / stageRange;
        const tickY = 20 + fraction * graphHeight;
        const tickLine = document.createElementNS(svgNS, "line");
        tickLine.setAttribute("x1", graphOffsetX - 5);
        tickLine.setAttribute("x2", graphOffsetX);
        tickLine.setAttribute("y1", tickY);
        tickLine.setAttribute("y2", tickY);
        tickLine.setAttribute("stroke", "black");
        tickLine.setAttribute("stroke-width", "1");
        svg.appendChild(tickLine);
        const tickLabel = document.createElementNS(svgNS, "text");
        tickLabel.setAttribute("x", graphOffsetX - 10);
        tickLabel.setAttribute("y", tickY + 4);
        tickLabel.setAttribute("font-size", "21");
        tickLabel.setAttribute("fill", "black");
        tickLabel.setAttribute("text-anchor", "end");
        tickLabel.textContent = tickVal.toFixed(1);
        svg.appendChild(tickLabel);
      }
      // Data path with stroke-width increased by 10% (6.6)
      const pathData = dataPoints.map((pt, i) => {
        const x = scaleX(pt.dateObj);
        const y = scaleY(pt.stage);
        return (i === 0 ? 'M' : 'L') + x + ',' + y;
      }).join(' ');
      const polyline = document.createElementNS(svgNS, "path");
      polyline.setAttribute("d", pathData);
      polyline.setAttribute("stroke", "black");
      polyline.setAttribute("fill", "none");
      polyline.setAttribute("stroke-width", "6.6");
      svg.appendChild(polyline);
      // Flood line
      const floodY = graphHeight - ((floodThreshold - minStage) / stageRange) * graphHeight + 20;
      const floodLine = document.createElementNS(svgNS, "line");
      floodLine.setAttribute("x1", graphOffsetX);
      floodLine.setAttribute("x2", graphOffsetX + graphWidth);
      floodLine.setAttribute("y1", floodY);
      floodLine.setAttribute("y2", floodY);
      floodLine.setAttribute("stroke", "black");
      floodLine.setAttribute("stroke-dasharray", "6,3");
      floodLine.setAttribute("stroke-width", "4");
      svg.appendChild(floodLine);
      // Date labels along x-axis (without a "Date" label)
      const minDateLabel = minDate.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
      let lastDay = "";
      dataPoints.forEach((pt, i) => {
        const x = scaleX(pt.dateObj);
        const y = scaleY(pt.stage);
        const circle = document.createElementNS(svgNS, "circle");
        circle.setAttribute("cx", x);
        circle.setAttribute("cy", y);
        circle.setAttribute("r", 3);
        circle.setAttribute("fill", "black");
        svg.appendChild(circle);
        const dayLabel = pt.dateObj.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
        if (dayLabel !== minDateLabel && dayLabel !== lastDay) {
          lastDay = dayLabel;
          const label = document.createElementNS(svgNS, "text");
          label.setAttribute("x", x);
          label.setAttribute("y", 240);
          label.setAttribute("font-size", "30");
          label.setAttribute("fill", "black");
          label.setAttribute("text-anchor", "middle");
          label.textContent = dayLabel;
          svg.appendChild(label);
        }
        if (i === dataPoints.length - 1) {
          const measurement = document.createElementNS(svgNS, "text");
          measurement.setAttribute("x", x);
          measurement.setAttribute("y", y + 45);
          measurement.setAttribute("font-size", "35");
          measurement.setAttribute("font-weight", "bold");
          measurement.setAttribute("fill", "white");
          measurement.setAttribute("text-anchor", "middle");
          measurement.textContent = ` ${lastReadingStr} `;
          const rect = document.createElementNS(svgNS, "rect");
          setTimeout(() => {
            const bbox = measurement.getBBox();
            rect.setAttribute("x", bbox.x - 5);
            rect.setAttribute("y", bbox.y);
            rect.setAttribute("width", bbox.width + 10);
            rect.setAttribute("height", bbox.height);
            rect.setAttribute("fill", "black");
          }, 0);
          setTimeout(() => {
            const bbox = measurement.getBBox();
            rect.setAttribute("x", bbox.x - 5);
            rect.setAttribute("y", bbox.y);
            rect.setAttribute("width", bbox.width + 10);
            rect.setAttribute("height", bbox.height);
            svg.insertBefore(rect, measurement);
          }, 0);
          svg.appendChild(measurement);
        }
      });
      container.appendChild(svg);
    }

    // ----------------------------------------------------------
    // 8) fetchNWSData: Weather Conditions
    // ----------------------------------------------------------
    function fetchNWSData() {
      const nwsTime = new Date().toLocaleString(undefined, { dateStyle: 'short', timeStyle: 'short' });
      document.getElementById('weather-timestamp').textContent = "Last updated: " + nwsTime;
      document.getElementById('alerts-timestamp').textContent = "Last updated: " + nwsTime;
      document.getElementById('rainfall-timestamp').textContent = "Last updated: " + nwsTime;
      const pointUrl = `https://api.weather.gov/points/${LAT},${LON}`;
      fetch(pointUrl)
        .then(res => res.json())
        .then(pointData => {
          const obsUrl = pointData.properties.forecastHourly;
          const gridUrl = pointData.properties.forecast;
          const alertZone = pointData.properties.forecastZone;
          fetch(obsUrl)
            .then(res => res.json())
            .then(obsData => {
              if (obsData.properties && obsData.properties.periods && obsData.properties.periods.length > 0) {
                const now = obsData.properties.periods[0];
                const tempF = now.temperature;
                const tempC = ((tempF - 32) * 5/9).toFixed(1);
                document.getElementById('weather-temp-F').textContent = `${tempF ?? '--'}°F`;
                document.getElementById('weather-temp-C').textContent = `${tempC}°C`;
                document.getElementById('weather-forecast').textContent = now.shortForecast || 'N/A';
                document.getElementById('weather-wind').textContent = `Wind: ${now.windSpeed || '--'} mph`;
                document.getElementById('weather-humidity').textContent = `Humidity: ${now.relativeHumidity && now.relativeHumidity.value ? now.relativeHumidity.value : '--'}%`;
                document.getElementById('weather-icon').innerHTML = getWeatherIcon(now.shortForecast);
                updateHeatRisk(tempF, now.relativeHumidity ? now.relativeHumidity.value : 0);
              }
            })
            .catch(err => console.error('Error fetching weather observations:', err));
          fetch(gridUrl)
            .then(res => res.json())
            .then(gridData => {
              if (gridData.properties && gridData.properties.periods) {
                const days = gridData.properties.periods.slice(0, 3);
                document.getElementById('rainfall-forecast-1').textContent =
                  `${days[0]?.name || 'Day1'}: ${days[0]?.shortForecast || 'N/A'}`;
                document.getElementById('rainfall-forecast-2').textContent =
                  `${days[1]?.name || 'Day2'}: ${days[1]?.shortForecast || 'N/A'}`;
                document.getElementById('rainfall-forecast-3').textContent =
                  `${days[2]?.name || 'Day3'}: ${days[2]?.shortForecast || 'N/A'}`;
              }
            })
            .catch(err => console.error('Error fetching rainfall forecast:', err));
          if (alertZone) {
            const zoneId = alertZone.split('/').pop();
            const alertUrl = `https://api.weather.gov/alerts/active/zone/${zoneId}`;
            fetch(alertUrl)
              .then(res => res.json())
              .then(alertData => {
                if (alertData.features && alertData.features.length > 0) {
                  const alertMsg = alertData.features.map(a => a.properties.headline).join(' | ');
                  document.getElementById('alert-message').textContent = alertMsg;
                } else {
                  document.getElementById('alert-message').textContent = 'No alerts at this time.';
                }
              })
              .catch(err => console.error('Error fetching alerts:', err));
          }
        })
        .catch(err => console.error('Error fetching NWS points data:', err));
    }

    // ----------------------------------------------------------
    // 9) fetchRiverData & renderRiverGraph: River & Water Levels
    // ----------------------------------------------------------
    function fetchRiverData() {
      const end = new Date();
      const start = new Date();
      start.setDate(end.getDate() - 4);
      const format = d => d.toISOString().split('.')[0];
      const url = `https://waterservices.usgs.gov/nwis/iv/?format=json&sites=02096960&parameterCd=00065&startDT=${format(start)}&endDT=${format(end)}&siteStatus=all`;
      fetch(url)
        .then(res => res.json())
        .then(data => {
          const siteProps = data.value.timeSeries[0].sourceInfo.siteProperty;
          if (siteProps) {
            siteProps.forEach(prop => {
              if (prop.propertyName === "floodStage") {
                floodThreshold = parseFloat(prop.value);
              }
            });
          }
          const rawValues = data.value.timeSeries[0].values[0].value || [];
          const floatValues = rawValues
            .map(v => ({ dateTime: v.dateTime, stage: parseFloat(v.value) }))
            .filter(pt => !isNaN(pt.stage));
          if (floatValues.length === 0) {
            document.getElementById('river-stage').textContent = 'No data available';
            return;
          }
          const lastReading = floatValues[floatValues.length - 1].stage;
          const lastReadingStr = `${lastReading.toFixed(2)} ft`;
          document.getElementById("river-timestamp").textContent = new Date().toLocaleString(undefined, { dateStyle: 'short', timeStyle: 'short' });
          const statusEl = document.getElementById("flood-status");
          if (lastReading >= floodThreshold) {
            statusEl.textContent = "AT OR ABOVE FLOOD STAGE";
            statusEl.style.fontSize = "48px";
            statusEl.style.backgroundColor = "black";
            statusEl.style.color = "white";
            statusEl.style.textTransform = "uppercase";
            statusEl.style.padding = "5px";
            statusEl.style.margin = "0 auto";
          } else {
            statusEl.innerHTML = "&#9888; BELOW FLOOD STAGE";
            statusEl.style.fontSize = "48px";
            statusEl.style.backgroundColor = "white";
            statusEl.style.color = "black";
            statusEl.style.textTransform = "uppercase";
            statusEl.style.padding = "5px";
            statusEl.style.margin = "0 auto";
          }
          const groupedValues = groupBy3HourBlocks(floatValues);
          renderRiverGraph(groupedValues, floodThreshold, lastReadingStr);
        })
        .catch(err => {
          console.error('USGS River Data fetch error:', err);
          document.getElementById('river-stage').textContent = 'Error fetching data';
        });
    }

    function groupBy3HourBlocks(dataArray) {
      const blockMap = {};
      dataArray.forEach(pt => {
        const date = new Date(pt.dateTime);
        const y = date.getFullYear();
        const m = date.getMonth();
        const d = date.getDate();
        const hBlock = Math.floor(date.getHours() / 3) * 3;
        const blockDate = new Date(y, m, d, hBlock, 0, 0, 0);
        const key = blockDate.toISOString();
        if (!blockMap[key]) {
          blockMap[key] = { dateObj: blockDate, sum: 0, count: 0 };
        }
        blockMap[key].sum += pt.stage;
        blockMap[key].count += 1;
      });
      return Object.values(blockMap)
        .map(item => ({ dateObj: item.dateObj, stage: item.sum / item.count }))
        .sort((a, b) => a.dateObj - b.dateObj);
    }

    function renderRiverGraph(dataPoints, floodThreshold, lastReadingStr) {
      const container = document.getElementById("river-graph");
      container.innerHTML = "";
      if (!dataPoints.length) return;
      let minStage = Math.min(...dataPoints.map(d => d.stage));
      let maxStage = Math.max(...dataPoints.map(d => d.stage));
      maxStage = Math.max(maxStage, 6); // Ensure at least 6 ft on y-axis
      minStage = Math.min(minStage, floodThreshold);
      maxStage = Math.max(maxStage, floodThreshold);
      const stageRange = (maxStage - minStage) || 1;
      const minDate = dataPoints[0].dateObj;
      const maxDate = dataPoints[dataPoints.length - 1].dateObj;
      const totalMillis = maxDate - minDate;
      const svgWidth = 1152;
      const svgHeight = 280;
      const graphHeight = 180;
      const graphOffsetX = 60;
      const graphWidth = svgWidth - graphOffsetX - 20;
      const svgNS = "http://www.w3.org/2000/svg";
      const svg = document.createElementNS(svgNS, "svg");
      svg.setAttribute("width", svgWidth);
      svg.setAttribute("height", svgHeight);
      svg.setAttribute("viewBox", `0 0 ${svgWidth} ${svgHeight}`);
      // Add y-axis label "Water Level (ft)"
      const yLabel = document.createElementNS(svgNS, "text");
      yLabel.setAttribute("x", 20);
      yLabel.setAttribute("y", 140);
      yLabel.setAttribute("font-size", "21");
      yLabel.setAttribute("font-weight", "bold");
      yLabel.setAttribute("fill", "black");
      yLabel.textContent = "Water Level (ft)";
      yLabel.setAttribute("transform", "rotate(-90 20,140)");
      svg.appendChild(yLabel);
      function scaleX(dateObj) {
        const currentMillis = dateObj - minDate;
        return graphOffsetX + (currentMillis / totalMillis) * graphWidth;
      }
      function scaleY(stage) {
        return graphHeight - ((stage - minStage) / stageRange) * graphHeight + 20;
      }
      // Y-axis ticks (font-size 21px; no "ft")
      const startTick = Math.floor(minStage * 2) / 2;
      const endTick = Math.ceil(maxStage * 2) / 2;
      for (let tickVal = startTick; tickVal <= endTick; tickVal += 0.5) {
        const fraction = (maxStage - tickVal) / stageRange;
        const tickY = 20 + fraction * graphHeight;
        const tickLine = document.createElementNS(svgNS, "line");
        tickLine.setAttribute("x1", graphOffsetX - 5);
        tickLine.setAttribute("x2", graphOffsetX);
        tickLine.setAttribute("y1", tickY);
        tickLine.setAttribute("y2", tickY);
        tickLine.setAttribute("stroke", "black");
        tickLine.setAttribute("stroke-width", "1");
        svg.appendChild(tickLine);
        const tickLabel = document.createElementNS(svgNS, "text");
        tickLabel.setAttribute("x", graphOffsetX - 10);
        tickLabel.setAttribute("y", tickY + 4);
        tickLabel.setAttribute("font-size", "21");
        tickLabel.setAttribute("fill", "black");
        tickLabel.setAttribute("text-anchor", "end");
        tickLabel.textContent = tickVal.toFixed(1);
        svg.appendChild(tickLabel);
      }
      // Data path with stroke-width 6.6 (10% increase)
      const pathData = dataPoints.map((pt, i) => {
        const x = scaleX(pt.dateObj);
        const y = scaleY(pt.stage);
        return (i === 0 ? 'M' : 'L') + x + ',' + y;
      }).join(' ');
      const polyline = document.createElementNS(svgNS, "path");
      polyline.setAttribute("d", pathData);
      polyline.setAttribute("stroke", "black");
      polyline.setAttribute("fill", "none");
      polyline.setAttribute("stroke-width", "6.6");
      svg.appendChild(polyline);
      // Flood line
      const floodY = graphHeight - ((floodThreshold - minStage) / stageRange) * graphHeight + 20;
      const floodLine = document.createElementNS(svgNS, "line");
      floodLine.setAttribute("x1", graphOffsetX);
      floodLine.setAttribute("x2", graphOffsetX + graphWidth);
      floodLine.setAttribute("y1", floodY);
      floodLine.setAttribute("y2", floodY);
      floodLine.setAttribute("stroke", "black");
      floodLine.setAttribute("stroke-dasharray", "6,3");
      floodLine.setAttribute("stroke-width", "4");
      svg.appendChild(floodLine);
      // Date labels along x-axis
      const minDateLabel = minDate.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
      let lastDay = "";
      dataPoints.forEach((pt, i) => {
        const x = scaleX(pt.dateObj);
        const y = scaleY(pt.stage);
        const circle = document.createElementNS(svgNS, "circle");
        circle.setAttribute("cx", x);
        circle.setAttribute("cy", y);
        circle.setAttribute("r", 3);
        circle.setAttribute("fill", "black");
        svg.appendChild(circle);
        const dayLabel = pt.dateObj.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
        if (dayLabel !== minDateLabel && dayLabel !== lastDay) {
          lastDay = dayLabel;
          const label = document.createElementNS(svgNS, "text");
          label.setAttribute("x", x);
          label.setAttribute("y", 240);
          label.setAttribute("font-size", "30");
          label.setAttribute("fill", "black");
          label.setAttribute("text-anchor", "middle");
          label.textContent = dayLabel;
          svg.appendChild(label);
        }
        if (i === dataPoints.length - 1) {
          const measurement = document.createElementNS(svgNS, "text");
          measurement.setAttribute("x", x);
          measurement.setAttribute("y", y + 45);
          measurement.setAttribute("font-size", "35");
          measurement.setAttribute("font-weight", "bold");
          measurement.setAttribute("fill", "white");
          measurement.setAttribute("text-anchor", "middle");
          measurement.textContent = ` ${lastReadingStr} `;
          const rect = document.createElementNS(svgNS, "rect");
          setTimeout(() => {
            const bbox = measurement.getBBox();
            rect.setAttribute("x", bbox.x - 5);
            rect.setAttribute("y", bbox.y);
            rect.setAttribute("width", bbox.width + 10);
            rect.setAttribute("height", bbox.height);
            rect.setAttribute("fill", "black");
          }, 0);
          setTimeout(() => {
            const bbox = measurement.getBBox();
            rect.setAttribute("x", bbox.x - 5);
            rect.setAttribute("y", bbox.y);
            rect.setAttribute("width", bbox.width + 10);
            rect.setAttribute("height", bbox.height);
            svg.insertBefore(rect, measurement);
          }, 0);
          svg.appendChild(measurement);
        }
      });
      container.appendChild(svg);
    }

    // ----------------------------------------------------------
    // 10) fetchNWSData: Weather Conditions
    // ----------------------------------------------------------
    function fetchNWSData() {
      const nwsTime = new Date().toLocaleString(undefined, { dateStyle: 'short', timeStyle: 'short' });
      document.getElementById('weather-timestamp').textContent = "Last updated: " + nwsTime;
      document.getElementById('alerts-timestamp').textContent = "Last updated: " + nwsTime;
      document.getElementById('rainfall-timestamp').textContent = "Last updated: " + nwsTime;
      const pointUrl = `https://api.weather.gov/points/${LAT},${LON}`;
      fetch(pointUrl)
        .then(res => res.json())
        .then(pointData => {
          const obsUrl = pointData.properties.forecastHourly;
          const gridUrl = pointData.properties.forecast;
          const alertZone = pointData.properties.forecastZone;
          fetch(obsUrl)
            .then(res => res.json())
            .then(obsData => {
              if (obsData.properties && obsData.properties.periods && obsData.properties.periods.length > 0) {
                const now = obsData.properties.periods[0];
                const tempF = now.temperature;
                const tempC = ((tempF - 32) * 5/9).toFixed(1);
                document.getElementById('weather-temp-F').textContent = `${tempF ?? '--'}°F`;
                document.getElementById('weather-temp-C').textContent = `${tempC}°C`;
                document.getElementById('weather-forecast').textContent = now.shortForecast || 'N/A';
                document.getElementById('weather-wind').textContent = `Wind: ${now.windSpeed || '--'} mph`;
                document.getElementById('weather-humidity').textContent = `Humidity: ${now.relativeHumidity && now.relativeHumidity.value ? now.relativeHumidity.value : '--'}%`;
                document.getElementById('weather-icon').innerHTML = getWeatherIcon(now.shortForecast);
                updateHeatRisk(tempF, now.relativeHumidity ? now.relativeHumidity.value : 0);
              }
            })
            .catch(err => console.error('Error fetching weather observations:', err));
          fetch(gridUrl)
            .then(res => res.json())
            .then(gridData => {
              if (gridData.properties && gridData.properties.periods) {
                const days = gridData.properties.periods.slice(0, 3);
                document.getElementById('rainfall-forecast-1').textContent =
                  `${days[0]?.name || 'Day1'}: ${days[0]?.shortForecast || 'N/A'}`;
                document.getElementById('rainfall-forecast-2').textContent =
                  `${days[1]?.name || 'Day2'}: ${days[1]?.shortForecast || 'N/A'}`;
                document.getElementById('rainfall-forecast-3').textContent =
                  `${days[2]?.name || 'Day3'}: ${days[2]?.shortForecast || 'N/A'}`;
              }
            })
            .catch(err => console.error('Error fetching rainfall forecast:', err));
          if (alertZone) {
            const zoneId = alertZone.split('/').pop();
            const alertUrl = `https://api.weather.gov/alerts/active/zone/${zoneId}`;
            fetch(alertUrl)
              .then(res => res.json())
              .then(alertData => {
                if (alertData.features && alertData.features.length > 0) {
                  const alertMsg = alertData.features.map(a => a.properties.headline).join(' | ');
                  document.getElementById('alert-message').textContent = alertMsg;
                } else {
                  document.getElementById('alert-message').textContent = 'No alerts at this time.';
                }
              })
              .catch(err => console.error('Error fetching alerts:', err));
          }
        })
        .catch(err => console.error('Error fetching NWS points data:', err));
    }

    // ----------------------------------------------------------
    // 11) Initial Data Fetch & Periodic Refresh
    // ----------------------------------------------------------
    function fetchAllData() {
      fetchRiverData();
      fetchAQIData();
      fetchNWSData();
    }
    fetchAllData();
    setInterval(fetchAllData, 10 * 60 * 1000);
  </script>
</body>
</html>
